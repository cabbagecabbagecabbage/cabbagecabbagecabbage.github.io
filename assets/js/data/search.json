[ { "title": "My Competitive Programming Journey", "url": "/posts/My-Competitive-Programming-Journey/", "categories": "Personal Reflection", "tags": "competitive-programming", "date": "2022-07-02 08:00:00 -0400", "snippet": "PrefaceNow that I’ve “retired” from serious competitive programming training, I think it would be meaningful to document and reflect on my experience, especially considering the hundreds of hours I’ve invested into it. I’ll be skipping over the technical details of my training and less significant contest results (Google Kickstart, Codeforces rounds, DMOJ contests, etc.).Before It All Started…The answer to “When did you start learning competitive programming?” would technically be Grade 8. I attended an after-school program, CodeReach, which introduced me to various concepts in computer science, including simple algorithms. Of course, the problems I encountered were quite elementary (mostly loops and conditionals). I do remember learning some graph theory, but I didn’t understand it very well at the time.In Grade 9, I started high school and attended the computer science club. Traditionally, the computer science club has always focused on preparing for the Canadian Computing Competition. The concepts and problems I encountered here were much more in the spirit of competitive programming. I learned simple data structures like prefix sum arrays and simple algorithms such as Breadth-First Search and Depth-First Search. However, I still wouldn’t count these 2 years towards competitive programming experience because I was not very committed to it yet.It should be noted that I scored 73/75 on the Junior CCC that year because that was perhaps the moment I realized that I had some potential to excel in competitive programming. Unfortunately, I pushed aside any desire to be productive during the summer. An event earlier in the year led me to develop a tendency to indulge in entertainment with little restraint as a form of escapism. Regrettably, the summer passed without me doing anything particularly meaningful.Start of My JourneyNear the start of the school year, I was scrolling through the computer science club Discord server where I found out that some of the seniors (namely, S, G, and L) spent much of their summer working on competitive programming problems. I felt terrible about myself – I let my summer waste away while others worked hard to put themselves ahead. On September 14th, I decided to start devoting almost all my free time to competitive programming training. I recognize this as the proper beginning of my competitive programming journey.Trying to solve problems was extremely strenuous and time-consuming at first. A hard problem could take me more than 6 hours because of my lack of resources, assistance, and experience (not just with competitive programming but with coding in general). As a side note, this is why I try my best to provide the club members with learning resources and answer their help requests as promptly as possible now that I’m one of the teachers. I understand and sympathize with the frustration that comes with problem-solving, especially in the early stages of training.Despite my struggles, I committed myself to solve one problem every day. I documented my progress on my DMOJ profile, which kept me motivated throughout the year. Of course, some problems took me more than one day to solve, and sometimes I solved more than one problem. Regardless of whether it was followed strictly, the rule I imposed on myself made me much more productive.As the year went on, I found online resources and communities that made the grind a lot less frustrating. My improvement was noticeable: after a few months, I was competing with the seniors for first and second place in the computer science club contests, even though they had much more experience than me. There was an invaluable feedback loop occurring: the more I practiced, the more improvement I noticed; the more improvement I noticed, the more motivated I was to practice. I can only hope to replicate this cycle in every pursuit of expertise.CCC 2021Six months (and around 300 problems solved) after I started my competitive programming journey, the Canadian Computing Competition took place. CCC 2021 was one of the “luckiest” performances of my contest career. S2 was almost identical to a problem I had done a few days before the contest. I finished the first 2 problems within 10 minutes of the 3-hour window. S3 was a problem I had never encountered before. I was very lucky to solve it because I was only able to observe that the values resembled a discrete unimodal function after I instinctively printed out all the brute-forced values. I solved this problem by deriving the ternary search algorithm on my own (I had never seen the algorithm before), which I’m not sure I could do if I were put in that spot again. I was able to salvage 7 partial points from S4. The subtask only involved unweighted SSSP – a problem I had done many times in my practice.I scored 55/75 points in the end, which put me first on the scoreboard of the club. While I celebrated my relatively successful performance, I made sure that I did not relax: I immediately resumed my competitive programming training the same night the CCC took place.ECOO 2021Three months later, the ECOO Programming Contest took place. ECOO was traditionally a team contest where you collaborate with a few other programmers to solve problems. However, COVID forced everything (in 2021) to be online, so it was held as an individual contest instead.Placing 12th in the province is undoubtedly my most perplexing achievement, considering that I can easily name 20 Toronto kids (or, at least, their DMOJ handles) who would destroy me in their sleep under normal circumstances. I must suspect that there were some technical difficulties with the judge that impeded others’ progress.Below is a screenshot of me being 4th on the scoreboard at one point, taken out of disbelief.It’s funny that, after lurking in the DMOJ community for a while, I can almost tell who these people are just by their school names. On this scoreboard, 1st is probably zhouzixiang2004, 2nd is probably Dormi (since 4fecta is 667510_UniversityofTorontoSchools_2), 3rd is probably Plasmatic. I had no business being right below these Grandmasters 50+ minutes into the contest.The final scoreboard can be found here.Summer of 2021I believe it was around this point that I began to plateau. I still practiced a lot, but my improvement slowed down. I am inclined to attribute this to the law of diminishing returns: the better you are at something, the harder it is to improve significantly.While lurking the DMOJ Discord server, I discovered that an experienced competitive programmer was curating a set of problems for CCC training. I encountered many educational and elegant problems as I worked through the set throughout the summer. One of my proudest solves from this problem set is Grasshopper Route. It took me several days of intermittent attempts to solve, but in the end, I came up with (as far as I know) a unique solution on my own.However, in hindsight, I don’t think it was entirely productive for me to attempt these problems. The reason is very simple: the majority of these problems are way too difficult for me. That was something I refused to admit, despite me requiring assistance on more than half of the problems I invested hours into. To be clear, I don’t think there’s anything wrong with the problem set itself - this is probably a great resource for people who can legitimately solve these problems in a contest setting.There’s no doubt that my problem-solving skills improved by attempting these problems, but since I wasn’t practicing problems of appropriate difficulty in a contest setting, I don’t think it effectively translated to more successful contest performances despite the effort I invested.CCC 2022I did not practice as much in the 2022 school year for a couple of reasons; it took me many hours to prepare lessons for the senior stream every week and come up with/find problems to put on the contests, aside from a busier workload from school. I still tried to find time to do some problems here and there, but I didn’t actively participate in online contests.With these petty excuses out of the way, CCC 2022 was an absolute nightmare for me - it depresses me to recollect the experience. Nevertheless, here’s roughly what happened (if memory serves): After misreading both S1 and S2, I solved them in 15 minutes. I read and attempted to understand S3, S4, and S5. This took me another 15 minutes. I worked on S3 by drawing out sample cases on paper. I made several useful observations, such as the construction for the maximum value and how the construction can be manipulated to reduce the value to the desired value. I had a rough idea of what the solution would look like around the 1h30 mark. I became extremely confused by edge cases and implementation bugs (something about subtracting iterators not giving me the proper index, but I can’t remember exactly what the bug was). My code (and my mental state) quickly became an absolute mess. Panic was through the roof by the 2h mark. I decided to leave S3 aside temporarily and instead start doing damage control by going for S4 partials. Again, I can’t recall what happened, but I kept running into bugs that I’d never seen before. In summary, I spent the last hour switching between working on S3 full and S4 partials. By the end, I had no idea what I was doing anymore. I had 3 different versions of my S3 solution (none of which worked), each one a complete mess that I eventually no longer understood. With a few minutes left, it occurred to me that I should at least get some partials for S3. My time ran out as I was coding up the second subtask.I ended with a laughable score of 33/75. I say laughable not because anyone made fun of it, but because I can’t mentally accept it after coming off of a rather successful year in 2021. Of course, 33 is not objectively a “bad” score considering the certificate cutoff is 30, but after hundreds of hours of training, it devastates me to end with a score that I could’ve achieved in 30 minutes with no prior training whatsoever.I vividly recall staring at the wall and being completely paralyzed for around 10 minutes after the contest, overwhelmed with disbelief, shame, and dejection.A Final BreathIt would be quite tragic if CCC 2022 was the last memorable contest of my journey. Thankfully, just before I retired, I successfully advanced to the Gold division of USACO in the 2022 US Open contest. I haven’t talked about USACO at all yet because I was stuck in the Silver division for 2 years; I advanced to Silver during my first contest and remained there for around 6 contests.For context, the US Open is usually the hardest contest of the season, so I didn’t expect to do well at all. Nevertheless, I took the contest one problem at a time, and before I knew it, I solved all the problems with 3 hours to spare in the 5-hour window. This performance was a much-needed suggestion that perhaps I was not as worthless as CCC 2022 exposed me to be.My Future Involvement in Competitive ProgrammingAs the contest organizer for next year’s computer science club, I’m clearly not fully detached from competitive programming yet. I don’t mind it though - setting problems for contests is something I enjoy, which is why I switched roles from senior-stream teacher to contest organizer in the first place.Aside from organizing contests for my club, I also recently started testing some contests on DMOJ, namely the “Yet Another Contest” series (YAC1, YAC2, YAC3). I find some of the problems quite interesting, so I’ll likely continue to be a tester as long as I have the time (I prefer testing over doing the contest itself because I no longer want to be bothered with the stress that comes with competing seriously).I’ll also still be writing the CCC next year, as there is no reason not to - according to most sources, there is no penalty for a poor contest performance (i.e. the participation itself can only be helpful) in terms of university applications.Why Am I Retiring?There are many reasons why I’m choosing to “retire” from serious competitive programming training. Below are some of them: As I mentioned, I feel like my skill level is plateauing despite my training, which means I would have to invest an unreasonable amount of time and effort to improve significantly. Without noticing improvement, training feels very tedious. There’s also the fact that only a small fraction of training (especially as one progresses through the breadth of topics) will be directly helpful during the contest, which makes training feel unrewarding. I’m skeptical of how useful competitive programming is in the real world. Some would argue that it helps you with technical interviews (and I don’t doubt that), but I don’t think it’s necessary to spend hundreds of hours doing something that indirectly prepares me. There are still some differences between interview questions and competitive programming tasks, so if I were solely aiming to practice for interviews, I would just grind LeetCode instead. In terms of job search (aka getting you an interview in the first place), I guess I just haven’t seen enough evidence for competitive programming being effective for getting interviews. I know that Google Code Jam finalists get to interview at Google, but I don’t think anyone could reasonably debate that getting an interview normally is harder than becoming one of the top 20 competitive programmers in the world. Next year, I’ll be taking on the responsibility of being a co-director of MasseyHacks, so it might be unfeasible to balance school work, contest organizing, Math contests, and responsibilities as a co-director while also training seriously for programming contests. Frankly, qualifying for CCO in grade 12 isn’t as valuable as qualifying in grade 11 in terms of university applications, since you don’t get the CCC results before you apply for scholarships. There’s a misconception that qualifying for CCO guarantees admission to a certain university, but this is simply not true - I know someone who was rejected (not even deferred) despite making it to CCO in their final year. Though I understand that CCO qualification and strengthening university applications are not the be-all and end-all of doing competitive programming, they were certainly strong incentives. Honestly, even if I trained for CCC starting now, I don’t think I have a favourable probability of qualifying for CCO. The CCC happens only once every year. If CCC 2022 repeats itself next year after I train another couple of months for it, I would, once again, have almost nothing to show for all my effort. Objectively, taking this risk is not the smartest thing to do. In summary, I don’t want to spend my time and effort on something that is perhaps not very meaningful to me anymore. I simply don’t see a strong incentive for me to continue training.Do I Regret Doing Competitive Programming?Not at all. I want to make it clear that I’m not saying it’s a bad idea to invest effort into competitive programming. Rather, I think it’s a bad idea to overinvest effort in something one no longer finds meaningful.Competitive programming has taught me many things, and I’m very grateful for how it has impacted me. I’ll be brief here since I plan to write about these things in detail in a future post. Competitive programming gave me something to focus on and helped me become a more productive person. Competitive programming gave me confidence in my problem-solving abilities and is entirely responsible for my understanding of many algorithms and data structures. Training for programming contests forced me to time-manage and handle stress as I balanced it with other responsibilities in my life. The continuous cycle of learning, practicing, and competing has made me a more efficient learner and helped me understand the learning strategies that were most effective for me. My successful contests gave me a taste of how rewarding hard work and dedication can be. My unsuccessful contests taught me how to manage discouragement after a poor performance.… and so on.In the end, I believe my pursuit was very worthwhile.Closing ThoughtsDespite the relatively short duration of my journey, it was full of irreplaceable experiences and meaningful transformation. Even though I now realize that developing my competitive programming prowess is no longer the most meaningful goal, it (at least) served as an important transition between my purposeless self and the person I am now, while teaching me many invaluable lessons along the way.I would like to express my sincere appreciation to everyone who inspired, encouraged, or assisted me along the way. I’m sure it would have been much more lonely and frustrating without you all.To my fellow competitive programmers, I wish you a fruitful journey." }, { "title": "Problem Analysis 6", "url": "/posts/Problem-Analysis-6/", "categories": "Academic", "tags": "competitive-programming, problem-analysis-series", "date": "2022-01-04 07:00:00 -0500", "snippet": "Atlantis2017 ACM ICPC North Central North America Regional Contest​Problem StatementTask Description​You may have heard of the lost city of Atlantis. As legend goes, Atlantis was a city of great wealth and power. Then the Gods became displeased with Atlantis and sank it into the ocean. What you may not have heard is the story of Demetrios, the only person in Atlantis with a ship at the time the city was pushed underwater.Demetrios was an incredibly selfish man and thought of only one thing when he noticed the water level in the city rising: collecting the wealth of accessible gold in Atlantis and transporting it into his ship before the treasure was lost forever. Luckily for Demetrios, when the water level began rising, the many guards keeping safe the gold stores abandoned their posts to seek safety.Demetrios knows the location of every gold store in Atlantis and how long it will take him to get to a particular store and back to his ship. He also knows the altitude at which each gold store resides, which determines when the store will be swallowed by the rising sea. The trouble is that he’s not sure he’ll have time to make it to every store before they become submerged. He now wonders the maximum number of stores he can visit prior to their respective submersion, if he picks his schedule optimally.During the 2017 NCNA Regional, the following clarification was posted: “Important: The gold store must remain above water during the ENTIRE trip to and from the store.”InputThe first line of input will contain the integer $n$, $(1 \\leq n \\leq 200000)$, the number of gold stores in Atlantis. The next $n$ lines will contain two integers on each line, $t_i$ and $h_i$, $(1 \\leq t_i,h_i \\leq 10^9)$, the round-trip time in seconds it will take Demetrios to visit store $i$ and return to his ship with the gold, and the feet above sea level of store $i$, respectively.OutputOutput the maximum number of gold stores Demetrios can visit such that each is visited prior to it becoming submerged. Assume sea level rises by one foot every second, starts at height $0$, and begins rising immediately.​AnalysisSummary of the Problem StatementLet us extract the key information from the problem: The sea level rises one foot every second, starting at height $0$. A store is defined by the time it takes to visit and its height. If we visit a store, we must be able to return before it is submerged (i.e., the sea level rises above its height).We are given $n$ of these stores, and we must choose the largest possible subset of these stores to visit satisfying the condition above.​With a clear grasp of the problem, we can begin to make a few observations.Part 1Since we are choosing some subset of stores to visit in some order, it is natural to consider whether the order in which we visit the stores matters with regards to whether it is possible to visit all the stores in the subset.Suppose there are 2 stores we want to visit, Store A and Store B. Store A takes 3 seconds to visit and has height 4 Store B takes 1 second to visit and has height 2If we visit the stores in that order, we will find that Store B is already submerged when we return from Store A because it took 3 seconds to go to the first store, but it only took 2 seconds for Store B to submerge.However, if we visit Store B first, we will be able to visit both stores because for Store A $1 \\leq 2$ and for Store B $1+3 \\leq 4$. Thus, we conclude that the order is indeed significant when determining whether it is possible to visit some set of stores.Now let’s consider a general case. Suppose there are 2 stores we want to visit, Store A and Store B. Store A takes $t_A$ seconds to visit and has height $h_A$. Store B takes $t_B$ seconds to visit and has height $h_B$.Again, there are 2 possible orders in which we can visit both. If we visit Store A then Store B, $t_A \\leq h_A$ and $t_A+t_B \\leq h_B$ must hold. Let’s call this Order 1. If we visit Store B then Store A, $t_B \\leq h_B$ and $t_B+t_A \\leq h_A$ must hold. Let’s call this Order 2.​Without loss of generality, let us assume that $h_A ≥ h_B$. We can then separate into two cases: If $t_B &gt; h_B$ Order 1 cannot visit both stores because $t_A+t_B \\leq h_B$ is not possible. Order 2 cannot visit both stores because $t_B \\leq h_B$ is not possible. If $t_B \\leq h_B$ Order 1 can visit both stores if and only if $t_A+t_B \\leq h_B$ (note that $t_A \\leq h_A$ is a subset of this constraint because $h_A ≥ h_B$). Order 2 can visit both stores if and only if $t_B+t_A \\leq h_A$.​We can see that in the first case the 2 orders are equivalent with respect to visiting both stores. However, in the second case, $t_B+t_A \\leq h_A$ is at least as “loose” of a constraint as $t_A+t_B \\leq h_B$ because of our assumption $h_A ≥ h_B$. Therefore, Order 2 is at least as good as, if not better than Order 1 when determining whether it is possible to visit both stores. Note: in the case that visiting both stores is not possible in either order and we are only visiting one of the stores, the order does not matter, which means our conclusion still holds.​With this example, we have shown that given any two stores, it is optimal to consider them in order of non-decreasing height. In layman’s terms, we are essentially saying “we should visit the stores that will submerge faster first”, which is actually pretty intuitive.Therefore, we should sort all $n$ stores in order of non-decreasing height and consider whether or not to include them in our subset in that order. With this insight, we can now rephrase the problem: Given the sorted sequence of $n$ stores, find the longest subsequence of stores such that every store in the subsequence can be visited before it submerges.​Formally, we now need to find the longest sequence $i_1, i_2, …, i_l$ $(1 \\leq l \\leq n)$ such that\\[\\sum_{k=1}^{j} t_{i_k} \\leq h_{i_j}\\]for all $1 \\leq j \\leq l$.​Part 2A quick glance at the constraints on $n$ $(1 \\leq n \\leq 2 \\times 10^5)$ and the values of $t_i$ and $h_i$ $ (1 \\leq t_i, h_i \\leq 10^9) $ rules out any brute force or dynamic programming solutions. Therefore, it is natural to wonder whether it is possible to greedily decide whether or not to include a store in our subsequence as we iterate through the $n$ sorted stores.Suppose we had 3 stores we can choose from to visit (sorted in non-decreasing height), as follows: Store A takes 3 seconds to visit and has height 3. Store B takes 2 seconds to visit and has height 4. Store C takes 3 seconds to visit and has height 5.If we consider the stores in order and include a store whenever it is feasible, we would greedily visit Store A since $3 \\leq 3$. However, when we get to Store B we will find that $3 + 2 &gt; 4$ and when we get to Store C we will find that $3 + 3 &gt; 5$; neither can be visited after visiting Store A.Instead, if we skipped over Store A and considered the rest of the stores in order, we will find that it is possible to visit both Store B and Store C since $2 \\leq 4$ and $2 + 3 \\leq 5$. From this, we can conclude that the naïve greedy strategy is not optimal.However, the idea of skipping over stores that hinder our optimality may prove very valuable to us. What if we include every store in our subsequence, then skip over as few stores as possible such that our subsequence satisfies the condition (see end of Part 1)? (Note: we want to remove as few stores as possible because we want the longest possible subsequence as our answer)Two questions that arise from this idea would be “When do we need to skip over stores?” “Which stores should we skip over to optimize our answer?”Suppose we are iterating through the stores and including every store in our subsequence as described. At some point, we may find that the sum of all the visiting times exceeds the height of the current store. This means that it is impossible to visit all the stores in our subsequence, and thus we need to skip over one or more of them so that the condition is satisfied.When deciding which stores should be skipped over, the following insight is crucial: every store contributes equally to our answer (the length of the subsequence), but the more time it takes to visit a store, the more it hinders our ability to include more stores because it increases the total time that is used to compare against the heights. Therefore, we should skip over the stores that take the longest to visit first until our subsequence satisfies the condition again.Furthermore, we can observe that if we continuously maintain a valid subsequence, we will never have to skip over more than one store whenever we include a new store. This is because we are considering the maximum time including the time to visit the store we just included, and since we started with a valid subsequence, skipping over this store or any store that takes at least as long to visit as this store will ensure that we result in a valid subsequence again.Final AlgorithmPiecing together the observations from Parts 1 and 2, we have the following algorithm outline:PseudocodeSort the stores in non-decreasing order.Iterate through the stores in orderFor each store: Include the store in our subsequence and increment answer. If the total time exceeds the height of the current store\tExclude the store in our subsequence that takes the longest to visit and decrement answerChoosing a Data StructureNow we just need a data structure that supports sub-linear time insertions and extractions for maximum. One such data structure is binary heap (implemented as std::priority_queue in C++), which supports $O(\\log n)$ inserts and extractions.Sample Implementation in C++#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;pair&lt;int,int&gt; stores[200005]; //pairs of {height, time}int main() {\tint n; cin &gt;&gt; n;\tfor (int i = 0; i &lt; n; ++i){\t\tcin &gt;&gt; stores[i].second &gt;&gt; stores[i].first;\t}\tsort(stores, stores + n);\tint ans = n;\tint totaltime = 0;\tpriority_queue&lt;int&gt; pq;\tfor (int i = 0; i &lt; n; ++i){\t\tpq.push(stores[i].second);\t\ttotaltime += stores[i].second;\t\tif (totaltime &gt; stores[i].first){\t\t\t--ans;\t\t\ttotaltime -= pq.top(); pq.pop();\t\t}\t}\tcout &lt;&lt; ans &lt;&lt; \"\\n\";\t\treturn 0;}The final time complexity is $O(n\\log n)$.Comments The official solution slides can be found here: NCNA17slides.pdf (uwaterloo.ca). This analysis was inspired by the solution shown on slide 23. The process of proving that sorting the stores in order of non-decreasing height is optimal (see Part 1) is very similar to the proofs in exchange argument dynamic programming problems. see Lecture #3 — Exchange arguments (sorting with dp) - Codeforces. Most other greedy algorithms choose the locally optimal choice at each step of the algorithm, but this greedy algorithm is creative because it chooses all the stores to visit at first, then removes the worst ones, making it much easier to prove correct and implement. I find this solution very clever. Like the first problem presented in the series, I discovered this problem through the “CCC Training Camp” problem set curated by Nick Wu. The full list of problems can be found here." }, { "title": "Problem Analysis 5", "url": "/posts/Problem-Analysis-5/", "categories": "Academic", "tags": "competitive-programming, problem-analysis-series", "date": "2022-01-02 07:00:00 -0500", "snippet": "King GruffCanadian Computing Competition: 2014 Stage 2, Day 1, Problem 2Problem StatementTask DescriptionKing Gruff the Wolf rules over a happy, prosperous land inhabited by adorable Foxen. Unfortunately for them, he is not a nice king at all, and wants to make their lives miserable!His country has $N$ $(1 \\leq N \\leq 10^5)$ cities, with $M$ $(1 \\leq M \\leq 10^5)$ roads running amongst them. The $i$-th road allows one to travel from city $X_i$ to a different city $Y_i$ $(1 \\leq X_i, Y_i \\leq N)$, in that direction only, and has a length of $L_i$ $(1 \\leq L_i \\leq 10^4)$ and a shutdown cost of $C_i$ $(1 \\leq C_i \\leq 10^4)$. There may be multiple roads running between a pair of cities, even in the same direction.King Gruff particularly dislikes the Foxen living in two different cities $A$ and $B$ $(1 \\leq A,B \\leq N)$, and would like to make it more inconvenient (or even impossible) to travel from city $A$ to city $B$. In particular, he’ll select a distance value $D$ $(1 \\leq D \\leq 10^9)$, and then simultaneously shut down every single road in his kingdom which is part of at least one path from city $A$ to city $B$ with total length no more than $D$. For each such road, however, he’ll have to dig into his royal treasury and pay its shutdown cost. A path consists of a sequence of roads such that each road (except the first) starts at the city that the previous road ended at, and may visit a city or road multiple times.​Gruff is having trouble making up his mind about what value of $D$ to choose, however - a larger value would make things more inconvenient for his Foxy subjects, but might cost him more money as well! As such, he’ll consider $Q$ $(1 \\leq Q \\leq 10^5)$ different values, $D_1, D_2, …, D_Q$. For each one, he’d like to know how many tax dollars would need to be spent to shut down all roads which lie on at least one sufficiently short path from city $A$ to city $B$. Since you don’t like Foxen either, you’ve agreed to help the Wolf write a program to calculate this!InputThe first line will contain 4 integers, each separated by a space: $N$ $(1 \\leq N \\leq 10^5)$, the number of cities, followed by $M$ $(1 \\leq M \\leq 10^5)$, the number of roads, followed by $A$ $(1 \\leq A \\leq N)$, the starting city, followed by $B$ $(1 \\leq B \\leq N)$, the ending city.Each of the next M lines contain four space-separated integers $X_i$, $Y_i$, $L_i$, and $C_i$ describing the road from $X_i$ to $Y_i$ with length $L_i$ and shutdown cost $C_i$, where $1 \\leq X_i, Y_i \\leq N$, $1 \\leq L_i, C_i \\leq 10^4$.The next line will contain $Q$ $(1 \\leq Q \\leq 10^5)$, the number of different distance values to consider.The next $Q$ lines each contain one integer $D_i$ $(1 \\leq D_i \\leq 10^9)$ which is the distance value to consider in shutting down roads.OutputThe output consists of $Q$ lines, each with one integer, representing the total cost required to shut down all necessary roads given a distance value of $D_i$, for $i = 1 … Q$.AnalysisSummarizing and ScoutingSince the problem statement is quite long and hard to understand at first glance, it’s helpful to summarize the key points of the problem statement. We are given a directed graph with edges that have two attributes: length and shutdown cost. We are given $Q$ queries as follows: Given a value $D$, consider every path from node $A$ to node $B$: if the path has total length not exceeding $D$, then every edge on that path should be shut down. Find the total shutdown cost (the sum of the shutdown cost of each edge that should be shut down).Looking at the constraints on $Q$, it is clear* we need to answer each of the queries in sublinear time. Since there is a linear amount of edges and we cannot process a linear amount of objects in sublinear time, we will need to do some preprocessing before attempting to answer the queries.*$N$, $M$, and $Q$ go up to $10^5$, so if our algorithm is quadratic or worse, it likely will not pass within 1 second: $(10^5)^2 &gt; 10^8$ (refer to Time Complexity · USACO Guide).Part 1Consider an edge in the graph. When determining whether it is part of a path from node $A$ to node $B$ with length not exceeding $D$ (for some given value $D$), it suffices to know the length of the shortest such path through that edge, and compare that with $D$. Therefore, we want to find this shortest length for all edges in subquadratic time.Let $dist(x,y)$ denote the length of the shortest path from node $x$ to node $y$.Recall that each edge goes in one direction from one node to another. Let’s call the starting node $S$ and the ending node $E$.A path from node $A$ to node $B$ going through the edge can be broken down into 3 parts: The path from node $A$ to node $S$ The path from node $S$ to node $E$ (the edge itself) The path from node $E$ to node $B$Since the shortest path problem has optimal substructure, the shortest path must be comprised of sub-paths with the shortest distance.Therefore, the shortest path from node $A$ to node $B$ going through the edge is equivalent to the sum of: $dist(A,S)$ The length of the edge (which is constant for a given edge) $dist(E,B)$Now we just need to be able to retrieve $dist(A,S)$ and $dist(E,B)$ for any given $S$ and $E$.Running an all-pairs shortest path on the graph is not viable here because the graph is fairly large. Luckily, we have a fixed node for each of our $dist(x,y)$ queries - $A$ and $B$ are constant for every edge we process.For $dist(A,S)$, notice that this is equivalent to the single-source shortest path (SSSP) problem, rooted at A.For $dist(E,B)$, we now have the destination fixed instead of the beginning. Here, notice that if we reverse all the edges in a graph $G$ to obtain $G’$, $dist(x,y) = dist’(y,x)$. Therefore, this is equivalent to the single-source shortest path on the reverse graph.An algorithm that solves the SSSP in subquadratic time is Dijkstra’s Algorithm. Now we can calculate the shortest distance from node $A$ to node $B$ through any edge in constant time. From now on, this will be referred to as the value​ of the edge.In case one is unfamiliar with Dijkstra’s Algorithm, this video explains it well.Part 2Let us call an edge valid if its value does not exceed a given value of $D$, and invalid otherwise.Each query has now been reduced to the following: Given edges with value and cost and a value of $D$, find the sum of the costs of all valid edges.Going through all the edges for each query would take linear time, which is not permissible for a linear amount of queries.However, if we sort the array of edges by non-decreasing value, notice that we will always be taking a prefix of these edges. Consider the valid edge in the array that furthest to the right: every edge to the left of it (including itself) must be valid, and every edge to the right of it must be invalid (or else the assumption that it is furthest to the right is false). This edge can be found by binary search in $O(\\log N)$ time per query.It remains to sum up the shutdown costs of these edges. Similarly, iterating through these edges for each query would take linear time, which is impermissible. Instead, notice that since we are computing the sum of a contiguous segment of values, a prefix sum array can be precomputed and used to find the sum of the prefixes in $O(1)$ time. This completes the solution.Final AlgorithmPiecing together parts 1 and 2, we have the following algorithm:PseudocodeRun Dijkstra's algorithm from A on the original graphRun Dijkstra's algorithm from B on the reverse graphCalculate the value of each edgeSort the edges by non-decreasing valuePrecompute a prefix sum array on the shutdown cost of the sorted edgesFor each query: Binary Search for the valid edge furthest to the right Return the prefix sum at that indexSample Implementation in C++#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 5;int n,m,a,b,dist[maxn],dist2[maxn];struct edge{\tint x,y,l,c;} edges[maxn];vector&lt;pair&lt;int,int&gt;&gt; adj[maxn],adj2[maxn],valcost;int main(){\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;\tfor (int i = 0; i &lt; m; ++i){\t\tint x,y,l,c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; l &gt;&gt; c;\t\tedges[i] = {x,y,l,c};\t\tadj[x].emplace_back(y,l);\t\tadj2[y].emplace_back(x,l);\t}\t\t//first dijkstras\tmemset(dist,0x3f,sizeof dist);\tdist[a] = 0;\tpriority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, greater&lt;pair&lt;int,int&gt;&gt;&gt; pq;\tpq.push({0,a});\twhile (!pq.empty()){\t\tint cost, node;\t\ttie(cost,node) = pq.top(); pq.pop();\t\tif (cost != dist[node]) continue;\t\tfor (pair&lt;int,int&gt; k: adj[node]){\t\t\tif (dist[k.first] &gt; cost + k.second){\t\t\t\tdist[k.first] = cost + k.second;\t\t\t\tpq.push({cost+k.second,k.first});\t\t\t}\t\t}\t}\t\t//second dijkstras\tmemset(dist2,0x3f,sizeof dist2);\tdist2[b] = 0;\tpq.push({0,b});\twhile (!pq.empty()){\t\tint cost, node;\t\ttie(cost,node) = pq.top(); pq.pop();\t\tif (cost != dist2[node]) continue;\t\tfor (pair&lt;int,int&gt; k: adj2[node]){\t\t\tif (dist2[k.first] &gt; cost + k.second){\t\t\t\tdist2[k.first] = cost + k.second;\t\t\t\tpq.push({cost+k.second,k.first});\t\t\t}\t\t}\t}\t\t//process edges\tint inf = 0x3f3f3f3f;\tfor (int i = 0; i &lt; m; ++i){\t\tint a = dist[edges[i].x], b = edges[i].l, c = dist2[edges[i].y];\t\tif (a != inf &amp;&amp; c != inf){\t\t\tvalcost.emplace_back(a+b+c,edges[i].c);\t\t}\t}\t\t//sort {value, edge} pairs\tsort(valcost.begin(),valcost.end());\t\t//prefix sum array\tfor (int i = 1; i &lt; valcost.size(); ++i){\t\tvalcost[i].second += valcost[i-1].second;\t}\t\t//handle queries\tint q; cin &gt;&gt; q;\twhile (q--){\t\tint d; cin &gt;&gt; d;\t\t//binary search\t\tint lo = 0, hi = valcost.size()-1, ans = -1;\t\twhile (lo &lt;= hi){\t\t\tint mid = (lo + hi) / 2;\t\t\tif (valcost[mid].first &lt;= d){\t\t\t\tans = mid;\t\t\t\tlo = mid + 1;\t\t\t}\t\t\telse {\t\t\t\thi = mid - 1;\t\t\t}\t\t}\t\tif (ans == -1) cout &lt;&lt; \"0\\n\";\t\telse cout &lt;&lt; valcost[ans].second &lt;&lt; \"\\n\";\t}\treturn 0;}Our final time complexity is linearithmic ($N$, $M$, and $Q$ have the same constraints).CommentsThis problem presents several useful concepts: Breaking down a path through an edge and taking advantage of the optimal substructure of shortest paths Dijkstra’s algorithm to solve the single-source shortest path problem, and symmetrically solving the single-destination shortest path problem by reversing the edges Combining sorting, preprocessing (prefix sum arrays), and binary search to answer each query in logarithmic timeIt should be noted that it is also possible to use the two-pointers method to do the final step instead of binary search + prefix sum arrays." }, { "title": "Problem Analysis 4", "url": "/posts/Problem-Analysis-4/", "categories": "Academic", "tags": "competitive-programming, problem-analysis-series", "date": "2021-12-31 07:00:00 -0500", "snippet": "Modulo SumCodeforces Round #319 Div.2 B​Problem StatementTask DescriptionYou are given a sequence of numbers $a_1, a_2, \\dots, a_n$ and a number $m$.Check if it is possible to choose a non-empty subsequence $a_i \\dots a_j$ such that the sum of the numbers in this subsequence is divisible by $m$.InputThe first line contains two numbers, $n$ and $m$ $(1 \\leq n \\leq 10^6, 2 \\leq m \\leq 10^3)$ - the size of the original sequence and the number such that [the] sum should be divisible by it.The second line contains $n$ integers $a_1, a_2, \\dots, a_n (0 \\leq a_i \\leq 10^9)$.OutputIn a single line print “YES” (without the quotes) if there exists the sought subsequence, or “NO” (without the quotes) if such subsequence doesn’t exist.AnalysisPart 1When we are tasked to choose some subsequence of a sequence such that it satisfies some condition, the technique of Dynamic Programming comes to mind (e.g. Longest increasing subsequence - Wikipedia). The general idea of a subsequence-related Dynamic Programming solution is to iterate through the elements and update the current state based on the addition of the current element onto the previous state, using additional dimensions as needed (depending on the conditions of the problem).Let’s refer to the sum of the elements in a subsequence as its value.​Let’s call a subsequence valid if its value is divisible by $m$.Let’s start off by defining our state. If we let $DP[i]$ store whether it is possible to choose a valid subsequence from the first $i$ elements, we’ll find it difficult to transition effectively since we need to know the value of the subsequence modulo $m$ (see Modular arithmetic - Wikipedia; a basic understanding of modular arithmetic is recommended for understanding the rest of the analysis).For example, if a subsequence has a value of 6, the element to be appended is 4 and $m$ happens to be 10, then the addition of the element would combine to satisfy to conditions of a valid subsequence; notice that we needed to know that the subsequence had value 6.Therefore, we need an additional dimension in our state to keep track of whether it is possible to obtain a subsequence that sums to $j$ modulo $m$. We now set our state as $DP[i][j]$ stores whether it is possible to choose a subsequence that sums to $j$ using the first $i$ elements.As we add an element to an existing subsequence, $a_i$ is added to the value. To obtain a sum of exactly $j$ modulo $m$, the state we transition from must have a value of $j - a_i$ modulo $m$. Therefore, the transition is $DP[i][j] = DP[i-1][(j-a_i+m) \\% m] $ (adding $m$ before applying the modulo operation again to prevent a negative index).It might seem like we solved the problem with Dynamic Programming, but there’s an important catch. The state needs to store up to $DP[n][m]$; looking at the constraints, $10^6 \\times 10^3 = 10^9 &gt; 10^8$ would exceed both the time and memory limits. This means we cannot use the Dynamic Programming solution directly.Part 2Notice that the problem only requires us to find out whether a valid sequence exists - we do not need to give an example of such a sequence.​ This motivates us to consider whether there is a situation where a valid sequence always exists.Let’s consider an arbitrary sequence $a$. Let $p_i$ store the sum of the elements from $a_1$ to $a_i$, modulo $m$. The key observation is that if there are two values $p_i$ and $p_j$ are equal for some $i &lt; j$, then the sum of the elements from $a_i$ exclusive to $a_j$ inclusive is divisible by $m$. Note it is important that $i ≠ j$, since we are looking for non-empty subsequences.To understand this, let’s review the usage of Prefix Sums. The idea is that every contiguous section of elements is the difference between two prefixes, the first ending at the right inclusive bound and the second ending at the left exclusive bound (read the linked article for a more detailed explanation). In this case, if two distinct prefix sums modulo $m$ are equal, that means the contiguous section of elements between them is exactly 0 modulo $m$, which by definition means that it is divisible by $m$.It remains to determine the conditions such that we are guaranteed to have two distinct prefixes with equal sums modulo $m$. Notice that we can only obtain values from 0 to $m-1$ if we operate under modulo $m$ - this is exactly $m$ values. By the Pigeonhole Principle, if we have more than $m$ values, at least two of them must be equal. Therefore, if we have a sequence longer than length $m$, then we will always be able to choose a valid sequence.From here, if we separate the case where $n &gt; m$ to always have the answer “YES”, we will only perform Dynamic Programming when $n \\leq m$. Now the maximum number of states becomes $10^3 \\times 10^3 = 10^6 &lt; 10^8$, which is permissible. This completes the solution.Final AlgorithmPiecing together Parts 1 and 2, we have the following solution:PseudocodeIf n &gt; m, the answer is \"YES\" and we are done.Otherwise, Initialize our base case to DP[0][0] = true since 0 elements will have a sum of 0 modulo m. For every a_i in the sequence For every j value from 0 to m DP[i][j] = DP[i-1][j] || DP[i-1][(j-a[i]+m)\\%m] Output \"YES\" if DP[n][m] is true, otherwise output \"NO\".Sample Implementation in C++#include &lt;bits/stdc++.h&gt;using namespace std;long long n,m;bool dp[1005][1005];int main(){\tcin &gt;&gt; n &gt;&gt; m;\tif (n &gt; m) cout &lt;&lt; \"YES\\n\";\telse {\t\tdp[0][0] = true;\t\tfor (int i = 1; i &lt;= n; ++i){\t\t\tlong long a; cin &gt;&gt; a; a %= m;\t\t\tfor (int j = 0; j &lt;= m; ++j){\t\t\t\tdp[i][j] = dp[i-1][j] || dp[i-1][(j-a+m)%m];\t\t\t}\t\t}\t\tcout &lt;&lt; (dp[n][m] ? \"YES\" : \"NO\") &lt;&lt; \"\\n\";\t}\treturn 0;}The final time complexity is $O(m^2)$.CommentsPart of this problem is standard Dynamic Programming, which is great for practice, but the cool part is recognizing the result of the $n &gt; m$ case. This application of Pigeonhole Principle might’ve seemed contrived, but Pigeonhole Principle is often used in problems where we deal with values under a certain modulo (especially in math). In fact, this exact method of using prefix sums to prove this case was mentioned in Problem-Solving Strategies by Arthur Engel in the “Box Principle” chapter (p.s. this is a great book for fellow math enthusiasts)." }, { "title": "Problem Analysis 3", "url": "/posts/Problem-Analysis-3/", "categories": "Academic", "tags": "competitive-programming, problem-analysis-series", "date": "2021-12-28 07:00:00 -0500", "snippet": "Count TrianglesCodeforces Round #643 Div.2 CProblem StatementTask DescriptionLike any unknown mathematician, Yuri has favourite numbers: $A$, $B$, $C$, and $D$, where $(A \\leq B \\leq C \\leq D)$. Yuri also likes triangles and once he thought: how many non-degenerate triangles with integer sides $x$, $y$, and $z$ exist, such that $(A \\leq x \\leq B \\leq y \\leq C \\leq z \\leq D)$ holds?Yuri is preparing problems for a new contest now, so he is very busy. That’s why he asked you to calculate the number of triangles with described property.The triangle is called non-degenerate if and only if its vertices are not collinear.InputThe first line contains four integers: $A$, $B$, $C$ and $D$ $(1 \\leq A \\leq x \\leq B \\leq y \\leq C \\leq z \\leq D \\leq 5 \\times 10^5)$ - Yuri’s favourite numbers.OutputPrint the number of non-degenerate triangles with integers sides $x$, $y$ and $z$ such that the inequality $(A \\leq x \\leq B \\leq y \\leq C \\leq z \\leq D)$ holds.AnalysisThe first thing we need to find out is the condition that our side lengths $x$, $y$ and $z$ must satisfy such that the vertices of the triangle will not be collinear. Consider the longest side of the triangle (A in diagram) and imagine the other two sides (B and C in diagram) each connected at the ends of the longest side. If the longest side is longer than the combined length of the two sides, they cannot close to form an angle no matter how we swing them.From this we conclude that the sum of the lengths of any two sides of a triangle must be greater than the remaining side. This is known as the triangle inequality. In the context of the problem, we are given $x \\leq y \\leq z$, so it suffices to ensure that $x + y &gt; z$.The problem now becomes “find the number of triples $(x,y,z)$ satisfying the constraints such that $x + y &gt; z$. The method we will use to solve this problem is to repeatedly optimize a naïve solution until we obtain a valid solution.Let’s first consider the obvious brute force solution: iterate through all possible values of $x$, $y$ and $z$ and add $1$ to our answer whenever $x + y &gt; z$.Pseudocode 1for each x value in [A,B]: for each y value in [B,C]: for each z value in [C,D]: if x + y &gt; z: add 1 to the answerprint the answerAlthough this solution would give the correct answer, it is too slow. Notice that $A$, $B$, $C$ and $D$ can go up to $5 \\times 10^5$, so it is possible for each of the intervals to have length $10^5$. Since we have 3 nested loops, we could be performing $(10^5)^3=10^{15}$ operations, which is way too many (see Time Complexity · USACO Guide; most importantly, C++ can handle about $10^8$ operations per second). We need to optimize this solution so that it can fit into the time limit.Let’s start by fixing a value of $z$. For this value of $z$, how many triples of $(x,y,z)$ satisfy $x + y &gt; z$? Since $z$ is fixed, the answer depends entirely on $x$ and $y$. The question then becomes, “how many pairs $(x,y)$ satisfy $x + y &gt; z$?”To answer this question efficiently, instead of looping through every single pair for every fixed value of $z$, we use the idea of precomputation. If we precompute an array defined as $arr[i]$ stores the number of pairs $(x,y)$ that satisfies $x + y = i$, we can loop through $arr[z+1]$ to $arr[B+C]$ instead. Notice that $z$ is at least $C$, so the interval is at worst $[C+1,B+C]$ which has length $B$.To precompute this array, we can loop through all pairs of $x$ and $y$ and add $1$ to $arr[x+y]$ for every pair. The reason this optimizes our solution is that we are doing this exactly once before we loop through the fixed values of $z$, instead of doing it every time.Pseudocode 2for each x in [A,B]: for each y in [B,C]: add 1 to arr[x+y]for each z in [C,D]: for each i in [z+1,B+C]: add arr[i] to answerprint the answerAgain, let’s approximate the number of operations we perform in our solution. In the first nested for-loop, we could perform $10^5 \\times 10^5 = 10^{10}$ operations. In the second nested for-loop, we could perform $10^5 \\times 10^5 = 10^{10}$ operations as well. In total, we could perform a factor of $10^{10}$ operations, which is much better than before but still impermissible (greater than $10^8$).Now that our solution is split into two parts: precomputation and using the array to compute the answer by fixing values of $z$. Let’s optimize them separately with data structures. These data structures are better explained by the linked articles, so I encourage you to go read up on them first if you are unfamiliar with them.The optimization of the second part is easier to see: we are repeatedly performing static range sum queries on $arr$ for every fixed value of $z$, so we can precompute a Prefix Sum Array to handle these queries in constant time.The optimization of the first part uses a very similar data structure. This time, notice that we are repeatedly performing range updates (more specifically, increments) for every fixed $x$ from $arr[x+B]$ to $arr[x+C]$. This can be optimized with the usage of a Difference Array by adding $1$ to $arr[x+B]$ and subtracting $1$ from $arr[x+C+1]$ for every $x$, then performing a linear scan (identical to precomputing the Prefix Sum Array) afterwards.Pseudocode 3for every x in [A,B]: add 1 to arr[x+B] subtract 1 from arr[x+C+1]for every i in [A+B, END): arr[i] = arr[i] + arr[i-1]for every i in [A+B, END): arr[i] = arr[i] + arr[i-1]for every z in [C,D]: add arr[END-1] - arr[z] to answerprint the answerFinally, let’s calculate the number of operations again.The first for-loop could perform a factor of $10^5$ operationsThe second and third for-loops (they are identical) could each perform a factor of $10^5$ operationsThe fourth for-loop could perform $10^5$ operationsIn total, we will not perform more than $10^6$ operations, which fits comfortably within the limit of $10^8$ operations per second. This completes the solution.Final AlgorithmSample Implementation in C++#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2e6 + 5;long long a,b,c,d,arr[maxn]; int main() {\tcin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\tfor (int x = a; x &lt;= b; ++x){\t\t++arr[x+b];\t\t--arr[x+c+1];\t}\t//to unfold the difference array\tfor (int i = a+b; i &lt; maxn; ++i){\t\tarr[i] += arr[i-1];\t}\t//precompute the psa\tfor (int i = a+b; i &lt; maxn; ++i){\t\tarr[i] += arr[i-1];\t}\tlong long ans = 0;\tfor (int z = c; z &lt;= d; ++z){\t\t//sum up arr[z+1] to the end\t\tans += arr[maxn-1] - arr[z];\t}\tcout &lt;&lt; ans &lt;&lt; \"\\n\";\treturn 0;}Comments This analysis presents the idea of repeatedly optimizing a slow brute-force solution to obtain a solution that is fast enough for the time limit (as well as how to calculate the operations). The two key methods here are optimizing using precomputation and optimizing using data structures, both of which are applicable in many problems. It should be noted that there is another solution to the problem. Using the same idea of fixing the value of $z$, we can mathematically determine the number of pairs $(x,y)$ such that $x+y &gt; z$ using the bounds on $x$ and $y$. " }, { "title": "Problem Analysis 2", "url": "/posts/Problem-Analysis-2/", "categories": "Academic", "tags": "competitive-programming, problem-analysis-series", "date": "2021-12-26 07:00:00 -0500", "snippet": "Odašiljači (Transmitters)Croatian Open Competition in Informatics ‘20 Contest 2 Problem #2Problem StatementSadly, this is the last time Sean will play James Bond.His mission is to network $n$ antennas that are scattered across a vast desert, which can be represented as a 2D plane. He will set the transmission radius of each antenna to be the same non-negative real number $r$. The range of an antenna is defined as the set of all points whose distance to the antenna is at most $r$. If ranges of two antennas have a common point, those antennas can directly communicate. Also, if antennas $A$ and $B$ can communicate, as well as antennas $B$ and $C$, then antennas $A$ and $C$ are also able to communicate, through antenna $B$.Sean wants to network the antennas, i.e. make it possible for every two antennas to communicate. Since M has limited his spending for this mission, and larger radii require more money, Sean will choose the smallest possible radius $r$. Help him solve this problem!InputThe first line contains an integer $n$ $(1 \\leq n \\leq 1000)$, the number of antennas.Each of the following $n$ lines contains integers $x_i$ and $y_i$ $(0 \\leq x_i,y_i \\leq 10^9)$, coordinates of the $i$-th antenna.OutputOutput the minimal radius.Your answer will be considered correct if its absolute or relative error doesn’t exceed $10^{-6}$.AnalysisThe problem asks for the smallest real number $r$ such that all the antennas are reachable from each other. When we are looking for the optimal value (especially when the answer is not limited to the set of integers) such that a condition is satisfied, the technique of binary searching should always be considered. In case one is unfamiliar with binary searching on monotonic functions, I give several examples in this lesson (skip through the irrelevant parts).Consider the minimal value of $r$ such that all the antennas are reachable from each other. Every value smaller than this value would not satisfy this condition, otherwise the assumption that it is minimal is false. Every value greater than this value would satisfy this condition, but would no longer be minimal since it is greater. This is why we can binary search for our answer.​How would we know if a value of $r$ would allow all the antennas to communicate with each other? To answer this, let’s visualize the problem with a diagram (from the original problem) of one of the sample inputs.Each of the antennas have a certain subset of antennas they can reach. This motivates us to see the antennas as nodes that are connected to other nodes. We know that two antennas can communicate only if their ranges share a common point. The furthest that two connected antennas can be is when their ranges just barely touch (sharing only 1 point), which is when the distance between them is exactly $2r$ (see antennas at (0,1) and (2,3), sharing the point (1,2)). Therefore, two antennas can communicate if and only if the distance between them is less than or equal to $2r$.To calculate the distance between any two points on the coordinate plane, we use the distance formula\\[d=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}\\]which can be derived from the Pythagorean theorem (hint: draw a triangle using the two points and a third point using the x-coordinate of one and the y-coordinate of the other).To check whether all the antennas can communicate, we can use any graph traversal algorithm such as Depth-first Search. Instead of going through an adjacency list, we loop through all other unvisited antennas. When we arrive at an antenna $u$ located at $(x_u,y_u)$, we check whether we can reach antenna $y$ by evaluating\\[\\sqrt{(x_u-x_v)^2+(y_u-y_v)^2} \\leq 2r\\]which can also be written as\\[(x_u-x_v)^2+(y_u-y_v)^2 \\leq 4r^2\\]to make the implementation easier.Final AlgorithmPiecing together all the elements, we have the following final algorithm:Sample Implementation in C++#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;double n,x[maxn],y[maxn];bool visited[maxn];double dist(int u, int v){\t//returns the square of the distance between u and v\tdouble dx = x[u] - x[v], dy = y[u] - y[v];\treturn dx*dx + dy*dy;}void dfs(int u, double r){\t//depth-first search to traverse the graph\tvisited[u] = true;\tfor (int v = 1; v &lt;= n; ++v){\t\t//only visited unvisited nodes that are close enough\t\tif (!visited[v] and dist(u,v) &lt;= 4*r*r) dfs(v,r);\t}}bool valid(double radius){\tdfs(1,radius); //start the traversal anywhere\tbool ans = true;\tfor (int i = 1; i &lt;= n; ++i){\t\tif (!visited[i]) ans = false; //if any node is unreached, the radius is invalid\t\tvisited[i] = false; //set unvisited for next call\t}\treturn ans;}int main(){\tcin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; ++i){\t\tcin &gt;&gt; x[i] &gt;&gt; y[i];\t}\t//binary search for the minimum radius\tdouble lo = 0, hi = 1e9;\twhile (hi - lo &gt; 1e-7){\t\tdouble mid = (lo + hi) / 2;\t\tif (valid(mid)) hi = mid;\t\telse lo = mid;\t}\tcout &lt;&lt; fixed &lt;&lt; setprecision(7) &lt;&lt; lo &lt;&lt; \"\\n\";\treturn 0;}The time complexity is $O(\\log{10^9}) \\times O(n^2) = O(n^2\\log{10^9})$, which fits in the time limit.CommentsThis problem combines ideas of binary search, geometry, and graph theory smoothly. Upon hearing “binary search”, many people think of trivial applications such as “finding whether a value exists in a sorted array of elements”; it is seen as a basic algorithm. As a result, many contestants neglect practicing binary search problems because they are supposedly simple, until they are unable to solve a non-trivial binary search problem in a contest (note: there certainly exists binary search problems much harder than this one!). Its importance is often overlooked - being able to find the optimal value (not limited to the set of integers!) in any monotonic function makes it one of the most useful algorithms." }, { "title": "Problem Analysis 1", "url": "/posts/Problem-Analysis-1/", "categories": "Academic", "tags": "competitive-programming, problem-analysis-series", "date": "2021-12-05 07:00:00 -0500", "snippet": "ChocolatePolish Olympiad in Informatics 2002/2003 Stage 1 Problem 2Problem StatementTask DescriptionWe are given a bar of chocolate composed of $m \\times n$ square pieces. One should break the chocolate into single squares. Parts of the chocolate may be broken along the vertical and horizontal lines as indicated by the broken lines in the picture. A single break of a part of the chocolate along a chosen vertical or horizontal line divides that part into two smaller ones. Each break of a part of the chocolate is charged a cost expressed by a positive integer. This cost does not depend on the size of the part that is being broken but only depends on the line the break goes along. Let us denote the costs of breaking along consecutive vertical lines with $x_1,x_2,\\dots,x_{m−1}$ and along horizontal lines with $y_1,y_2,\\dots,y_{n−1}$. The cost of breaking the whole bar into single squares is the sum of the successive breaks. One should compute the minimal cost of breaking the whole chocolate into single single squares.For example, if we break the chocolate presented in the picture first along the horizontal lines, and next each obtained part along vertical lines then the cost of that breaking will be\\[y_1 + y_2 + y_3 + 4 \\cdot (x_1 + x_2 + x_3 + x_4 + x_5)\\]Write a program which: reads the numbers $x_1,x_2,\\dots,x_{m-1}$ and $y_1,y_2,\\dots,y_{n-1}$, computes the minimal cost of breaking the whole chocolate into single squares, writes the result.InputIn the first line of the standard input there are two positive integers $m$ and $n$ separated by a single space, $2 \\leq m,n \\leq 1,000$. In the successive $m-1$ lines there are numbers $x_1,x_2,\\dots,x_{m-1}$, one per line, $1 \\leq x_i \\leq 1,000$. In the successive $n-1$ lines there are numbers $y_1,y_2,\\dots,y_{n-1}$, one per line, $1 \\leq y_i \\leq 1,000$.OutputYour program should write to the standard output. In the first and only line your program should write one integer - the minimal cost of breaking the whole chocolate into single squares.AnalysisIt isn’t immediately obvious what the optimal strategy is when cutting the chocolate: Along which line should we cut first? How does a cut across a line affect the cuts afterwards? This is when we “play around” with the problem - its never a bad idea to solve a trivial case by hand to get a feel for the problem.Consider a $2\\times2$ piece of chocolate with $y_1 = 1$ and $x_1 = 2$.Let’s first cut the chocolate horizontally along $y_1$, from which we obtain two $1\\times2$ pieces of chocolate. Each of these pieces are then cut along $x_1$, breaking them into single squares as required. The total cost incurred is $y_1 + 2 \\times x_1 = 1 + 2 \\times 2 = 5 $.Alternatively, we can cut vertically along $x_1$ first, leaving two $2\\times1$ pieces. Each of these pieces are then cut along $y_1$, breaking them into single squares as desired. The total cost incurred is $x_1 + 2 \\times y_1 = 2 + 2\\times1 = 4$.This example helps us notice several things: We must make a break along each line $y_1,y_2,\\dots,y_{n-1}$ and $x_1,x_2,\\dots,x_{m-1}$ at least once, otherwise there will be squares that are still connected by that line. When we break a piece horizontally, it produces two pieces; now when we try to make a vertical break along a line within each of the pieces, we will need to do it twice instead of once. When we break a piece vertically, it produces two pieces; now when we try to make a horizontal break along a line within each of the pieces, we will need to do it twice instead of once.Intuitively, to achieve the minimum cost, the more costly breaks should be done as little as possible. Since every line needs to be broken along at least once and every break affects all perpendicular breaks that come afterwards, we conclude that we should break along the lines in order of non-increasing cost (that is, the more costly lines should be broken along first).One final implementation detail is unclear: How will we know the number of necessary breaks along a given line? Recall that every horizontal break adds 1 to the number of breaks along any vertical line in the future (and vice versa). Thus the number of pieces that will need a vertical break along a given vertical line is exactly the number of horizontal breaks already made, plus 1. When implementing the solution, we keep track of whether the line we are processing is vertical/horizontal, and we keep maintain variables storing the number of horizontal breaks and the number of vertical breaks already made, incrementing as we make breaks.Final AlgorithmPseudocodepush horizontal lines into a containerpush vertical lines into a containersort the container in order of non-increasing costlet verticalBreaks = 0, horizontalBreaks = 0for every line in the container: if the line is horizontal: add (verticalBreaks + 1) * cost to answer add 1 to horizontalBreaks if the line is vertical: add (horizontalBreaks + 1) * cost to answer add 1 to verticalBreaksprint the answerSample Implementation in C++#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;int m,n;pair&lt;int,int&gt; lines[maxn*2];int main() {\tcin &gt;&gt; n &gt;&gt; m;\tfor (int i = 0; i &lt; m-1; ++i){\t\tint c; cin &gt;&gt; c;\t\tlines[i] = {c,0};\t}\tfor (int i = 0; i &lt; n-1; ++i){\t\tint c; cin &gt;&gt; c;\t\tlines[m-1+i] = {c,1};\t}\tsort(lines, lines + n + m - 2, greater&lt;pair&lt;int,int&gt;&gt;());\tint h = 1, v = 1, ans = 0;\tfor (int i = 0; i &lt; m + n - 2; ++i){\t\t// O(M+N)\t\tif (lines[i].second == 0){\t\t\tans += h * lines[i].first;\t\t\t++v;\t\t}\t\telse if (lines[i].second == 1){\t\t\tans += v * lines[i].first;\t\t\t++h;\t\t}\t}\tcout &lt;&lt; ans &lt;&lt; \"\\n\";\treturn 0;}The time complexity of the solution is $O((n+m)\\log{(n+m)})$ from sorting.Comments This problem teaches the usefulness of solving small cases by hand. The problem may seem difficult at first, but going through the possibilities of breaking up the chocolate makes the observations much more obvious. I discovered this problem through the “CCC Training Camp” problem set curated by Nick Wu. The full list of problems can be found here. " }, { "title": "Introduction to the Problem Analysis Series", "url": "/posts/Problem-Analysis-0/", "categories": "Academic", "tags": "competitive-programming, problem-analysis-series", "date": "2021-11-12 07:00:00 -0500", "snippet": "Note From the FutureThis series of six blog posts was originally a submission to the EWC4U course. Shout-out to Ms. D for allowing me to write about such a technical topic for this unit!I’ll make a few edits here and there, but I’ll mostly just be migrating the six posts over as-is. I might continue this series one day if I stumble upon a particularly elegant problem.IntroductionHello there. I’m a high school student who enjoys mathematical and algorithmic problem-solving. At the time of writing, I have about a year of experience in competitive programming, a mind-sport where contestants solve programming tasks as quickly as possible under certain constraints.Among all of the programming problems I solved last year, I found several to be particularly creative and educational. I hope to share some of the ideas in these problems with other problem-solving enthusiasts. In this series of blog posts, I will present the solutions to six problems of varying topics in order of increasing difficulty.I often get stuck on problems and read the problem editorials. An issue with many problem editorials is the lack of detail and explanation for the motivation needed to formulate the correct solution. I aim to provide a comprehensive exposition of the solutions to these problems by avoiding leaps in logic, presenting proofs for non-trivial claims, providing links to external resources, and navigating through multi-step solutions in an intuitive manner.This is not to say that no prerequisite experience in algorithmic problem solving is required to understand the analyses. Instead, I aim to educate/interest readers who are capable of making a decent attempt at the problems themselves and are willing to put in some effort to understand the problems and their solutions.I encourage readers to attempt the problems before reading the analyses. If the titles seem somewhat dull, that’s because I don’t want to spoil anything about the solution beforehand.Feel free to contact me if you have any questions, comments, or corrections. Have fun problem-solving!" } ]
